# CLI dry-run
ubl cap from-json samples/capsule.json -o - | ubl cap verify - --pk keys/pub.ed25519
ubl cap receipt add out.capsule.nrf --kind relay --node did:ex#k1 --sk keys/relay.sk -o out.capsule.h1.nrf
```

se quiser, j√° gero os esqueletos (`lib.rs`, tests, schemas e CLI) seguindo esses paths e abrimos PR com commits 1‚Üí6, um por item. üíö

## Prompt:
Varre de novo o arquivo e acha problemas a mais alem desses

## Response:
Pensou por 4m 56s

Boa! Revarri o **AI-NRF1-byte-main.zip** e achei mais pontos al√©m dos que j√° t√≠nhamos. Aqui v√£o **novos problemas** (com a√ß√£o direta de corre√ß√£o para cada um) üëá

1.  Naming can√¥nico inconsistente (NRF-1.1 / nrf1 vs ai-nrf1 / ubl-byte)  
    ‚Ä¢ Onde: `cli/nrf1/src/main.rs` (mensagens ‚ÄúNRF-1.1 CLI‚Äù), v√°rios READMEs/strings.  
    ‚Ä¢ Por que √© problema: confunde o ‚Äúbrand‚Äù e quebra o contrato que combinamos (ai-nrf1 / ubl-byte).  
    ‚Ä¢ O que fazer:
    *   Substituir em mensagens/ajuda/README: ‚ÄúNRF-1.1‚Äù‚Üí‚Äúai-nrf1‚Äù, ‚Äúnrf1‚Äù (quando for nome de formato)‚Üí‚Äúai-nrf1‚Äù; quando for camada ‚Äúmarca‚Äù, usar ‚Äúubl-byte‚Äù/‚Äúubl-json‚Äù.
*   Renomear banners/help do CLI e descrever ‚Äúai-nrf1 (canonical bytes)‚Äù.
    2.  Floats vazando da camada JSON (violam ‚Äúsem float‚Äù)  
    ‚Ä¢ Onde: `crates/ubl-json/src/lib.rs` (permite `serde_json::Number` com f64), `crates/reasoning-bit/src/lib.rs` (`f32 confidence`).  
    ‚Ä¢ Por que √© problema: ai-nrf1/œÅ pro√≠be float; qualquer caminho que aceite float permite n√£o-determinismo.  
    ‚Ä¢ O que fazer:
    *   Em `ubl-json`: rejeitar n√∫meros com ponto/expoente no parse (retornar `Err.FloatForbidden`) e mapear decimais sempre como **string can√¥nica** (regex de decimal de œÅ).
*   Em `reasoning-bit`: trocar `f32` por `DecimalString` (ex.: `String` validada pelo mesmo regex de œÅ) ou inteiro de base fixa (p.ex. mil√©simos em `i32`).
    3.  CIDs/bytes como `String` em endpoints (deveriam ser bytes can√¥nicos + view com prefixo)  
    ‚Ä¢ Onde: `services/registry/src/routes/receipts.rs` usa `String` para `cid`.  
    ‚Ä¢ Por que √© problema: canonicidade pede tipo bin√°rio (Bytes(32)) no objeto; o **view** √© que mostra `b3:<hex>`.  
    ‚Ä¢ O que fazer:
    *   Trocar campos CID/bytes para `[u8;32]`/`Vec<u8>` no modelo e **normalizar view** para `b3:<hex min√∫sculo>`.
*   Rejeitar qualquer `hex` fora de `[0-9a-f]` (for√ßar min√∫sculas).
    4.  Parser de hex can√¥nico s√≥ est√° no CLI; faltam guardas no servi√ßo  
    ‚Ä¢ Onde: `cli/nrf1/src/main.rs` j√° tem `parse_hex_lower()` (aceita vazio; exige par; s√≥ `[0-9a-f]`).  
    ‚Ä¢ Por que √© problema: os servi√ßos (`registry`) usam `hex::decode` direto, aceitando mai√∫sculas e n√£o emitindo erro canonizado.  
    ‚Ä¢ O que fazer:
    *   Extrair `parse_hex_lower()` para um crate utilit√°rio (ex.: `ai_nrf1_util`) e usar no `registry`/camada HTTP.
*   Sempre reemitir **lowercase** no view.
    5.  JSON-view can√¥nica ausente/sem contrato de prefixos  
    ‚Ä¢ Onde: n√£o h√° crate dedicado √† **view** (`ubl_json_view`).  
    ‚Ä¢ Por que √© problema: mistura representa√ß√£o bin√°ria e textual; n√£o h√° padroniza√ß√£o de `b3:`, `b64:`, `n:` (inteiro).  
    ‚Ä¢ O que fazer:
    *   Criar `impl/rust/ubl_json_view/` com `to_json/from_json` aplicando:
    *   `Bytes(32)` ‚Üí `b3:<hex>`; bytes arbitr√°rios ‚Üí `b64:<...>`
    *   Int64 ‚Üí `n:<decimal>` apenas quando necess√°rio (se quisermos distinguir tipos).
*   Validar NFC/ASCII **antes** de materializar bytes.
    6.  Roteiro de proibi√ß√£o/erro n√£o unificado (erros divergem)  
    ‚Ä¢ Onde: `nrf-core` define erros `InvalidUTF8/NotNFC/BOMPresent/...`; outras camadas retornam `anyhow`.  
    ‚Ä¢ Por que √© problema: auditoria quer **tabela de erros est√°veis**.  
    ‚Ä¢ O que fazer:
    *   Introduzir `ai_nrf1_errors` (enum √∫nico) e mapear todos os parsers/validadores para ele (sem `anyhow` gen√©rico em bordas p√∫blicas).
*   Atualizar mensagens do CLI para imprimir c√≥digo + descri√ß√£o curta.
    7.  Conformidade de ASCII/NFC para chaves DID/KID ausente (camada rede)  
    ‚Ä¢ Onde: servi√ßos/roteamento/registry aceitam `String` sem checar ASCII-only e NFC.  
    ‚Ä¢ Por que √© problema: especifica√ß√£o exige ASCII para DIDs/KIDs no cabe√ßalho (quando formos para Capsule), e strings NFC sempre.  
    ‚Ä¢ O que fazer:
    *   Adicionar `ensure_ascii()` + verifica√ß√£o NFC em entradas textuais de identifica√ß√£o (mesmo antes da Capsule).
*   Rejeitar caractere fora de ASCII b√°sico (DID/KID).
    8.  Invariantes de sets/ordena√ß√£o-por-bytes testados s√≥ em n√≠vel NRF; faltam KATs cruzados  
    ‚Ä¢ Onde: temos KATs de bytes em `tests/vectors`, mas faltam **differentials** entre Python ref e Rust para `Set`/`Map` complexos.  
    ‚Ä¢ Por que √© problema: f√°cil regress√£o na ordena√ß√£o por **bytes NRF** vs ordena√ß√£o por string.  
    ‚Ä¢ O que fazer:
    *   Ampliar `tests/differential/test_diff_cli_vs_python.py` cobrindo:
    *   `Set` com itens heterog√™neos (map, array, string) e duplicatas.
    *   `Map` com chaves confus√°veis NFC vs NFD (devem falhar ou normalizar conforme œÅ).
        9.  `ubl-storage` ainda sem pol√≠tica de **behavior-version** do AWS SDK  
    ‚Ä¢ Onde: `crates/ubl-storage/src/lib.rs` carrega AWS config; avisos deprecados podem voltar.  
    ‚Ä¢ Por que √© problema: estabilidade de runtime; builds diferentes ‚Üí comportamento diferente.  
    ‚Ä¢ O que fazer:
    *   Migrar para `aws_config::load_defaults(behavior_version = latest)` (ou fixar behavior-version) e documentar.
    10.  Mensagens do CLI ainda usam termos antigos e n√£o exibem **nome do formato**  
    ‚Ä¢ Onde: ajuda/erros em `cli/nrf1/src/main.rs`.  
    ‚Ä¢ Por que √© problema: devs precisam ver ‚Äúai-nrf1 bytes‚Äù expl√≠cito.  
    ‚Ä¢ O que fazer:
    *   Atualizar `--help`/usage: ‚Äúencode/decode ai-nrf1 (UBL-Byte)‚Äù.
*   Incluir nota: ‚ÄúJSON √© view; hash √© sobre bytes ai-nrf1.‚Äù
    11.  `reasoning-bit` compila mas n√£o tem **fronteira de serializa√ß√£o** definida  
    ‚Ä¢ Onde: `crates/reasoning-bit/src/lib.rs` exp√µe tipos com `f32` e campos livres.  
    ‚Ä¢ Por que √© problema: pode acabar serializando em ai-nrf1 sem œÅ.  
    ‚Ä¢ O que fazer:
    *   Marcar o crate como **no-std/sem-serialize** ou colocar `#[cfg(feature="serialize")]` com mapeamento **via œÅ** (proibindo float).
    12.  Falta teste KAT para **bytes vazios** na linha de comando (j√° aceito no parser)  
    ‚Ä¢ Onde: temos differential que cobre, mas n√£o h√° vetor fixo em `tests/vectors/valid`.  
    ‚Ä¢ Por que √© problema: regress√£o silenciosa.  
    ‚Ä¢ O que fazer:
    *   Adicionar `tests/vectors/valid/bytes_empty.hex` e um JSON-view correspondente.
    13.  `hex::decode` usado em rotas n√£o for√ßa **comprimento par** nem min√∫sculas por contrato  
    ‚Ä¢ Onde: `services/registry/src/routes/receipts.rs`.  
    ‚Ä¢ Por que √© problema: can√¥nico √© ‚Äúpar + min√∫sculas‚Äù; o decode puro aceita varia√ß√µes.  
    ‚Ä¢ O que fazer:
    *   Substituir por util `parse_hex_lower()` (ver item 4) e normalizar imediatamente.
    14.  Documenta√ß√£o interna ainda fala ‚ÄúNRF-1.1‚Äù em v√°rios locais  
    ‚Ä¢ Onde: docs/READMEs dentro do zip.  
    ‚Ä¢ Por que √© problema: desalinha com a spec oficial que te passei (ai-nrf1 / ubl-byte / ai-json-nrf1 / ubl-json).  
    ‚Ä¢ O que fazer:
    *   Passar um `ripgrep`/`sed` e atualizar termos + rodar uma revis√£o de exemplos/hex.
    15.  View JSON n√£o separa claramente **objeto can√¥nico** vs **view humana**  
    ‚Ä¢ Onde: hoje a mesma struct `Value` (NRF) transita para JSON em alguns caminhos.  
    ‚Ä¢ Por que √© problema: risco de algu√©m assinar **view** em vez de **bytes**.  
    ‚Ä¢ O que fazer:
    *   Criar tipos distintos: `AiNrf1Value` (bin√°rio) e `UblJsonView` (textual). Converter s√≥ via fun√ß√µes expl√≠citas `to_json_view()/from_json_view()`.

Se quiser, j√° te devolvo um patch aplicando **(1), (3‚Äì5), (10), (12‚Äì13, 15)** ‚Äî os que d√£o mais retorno com baixo risco ‚Äî e abro issues para (2), (7‚Äì9, 11, 14) porque exigem tocar mais crates. Quer que eu j√° gere o diff? üí•

## Prompt:
Transforme essa ultima mensagem em prompt bem explicativo e \objetivo

## Response:
Segue um **prompt √∫nico**, claro e direto, para colar onde quiser e executar as corre√ß√µes. üëá

* * *

PROMPT: Auditoria e Corre√ß√£o Can√¥nica ‚Äî AI-NRF1 (UBL-Byte) + Views
==================================================================

**Contexto:** Voc√™ vai auditar e corrigir o reposit√≥rio **AI-NRF1-byte-main.zip** garantindo canonicidade **ai-nrf1 (bytes)**, views JSON est√°veis, e alinhamento de naming (**ai-nrf1 / ai-json-nrf1 / ubl-byte / ubl-json**).  
**Objetivo:** Eliminar ambiguidade, padronizar tipos bin√°rios, endurecer parsers e alinhar documenta√ß√£o/CLI.  
**Entrega:** Patch com mudan√ßas, novos testes (KAT + integra√ß√£o) e atualiza√ß√£o de docs/CLI.

Instru√ß√µes gerais
-----------------

*   **Nunca** assine/hasheie a view JSON; **sempre** sobre bytes **ai-nrf1**.
*   **Bytes e CIDs** s√£o tipos bin√°rios no modelo; a view renderiza `b3:<hex>` (32B) ou `b64:<...>` (arbitr√°rio).
*   **Strings** NFC; **DID/KID** ASCII-only. **Sem floats** ‚Äî use decimal can√¥nico em string.
*   Erros p√∫blicos devem vir de um **enum √∫nico** (nada de `anyhow` gen√©rico na borda).
*   Atualize help/README/prints para a nova nomenclatura.

Itens (corrija todos)
---------------------

1.  **Naming can√¥nico inconsistente**  
    **Onde:** `cli/nrf1/src/main.rs`, READMEs/strings.  
    **Fa√ßa:** Padronize: formato = **ai-nrf1**; marca = **ubl-byte**/**ubl-json**. Atualize help e mensagens.
2.  **Floats vazando da camada JSON**  
    **Onde:** `crates/ubl-json`, `crates/reasoning-bit`.  
    **Fa√ßa:** Pro√≠ba `f32/f64` e n√∫meros com ponto/expoente. Use **decimal can√¥nico como string** (regex de œÅ). Se precisar de n√∫mero, use inteiro escalado.
3.  **CIDs/bytes modelados como String**  
    **Onde:** `services/registry/*`.  
    **Fa√ßa:** Troque para `[u8;32]`/`Vec<u8>`. View rende `b3:<hex min√∫sculo>`. Rejeite qualquer n√£o-min√∫sculo.
4.  **Parser de hex can√¥nico s√≥ no CLI**  
    **Onde:** rotas/servi√ßos usam `hex::decode`.  
    **Fa√ßa:** Extraia `parse_hex_lower()` para um util comum. Exija **comprimento par**, **\[0-9a-f\]**, aceite vazio quando aplic√°vel.
5.  **JSON-view can√¥nica ausente**  
    **Onde:** falta crate dedicado.  
    **Fa√ßa:** Crie `impl/rust/ubl_json_view/` com `to_json/from_json` (prefixos `b3:`, `b64:`). Valide NFC/ASCII antes de materializar.
6.  **Erros n√£o unificados**  
    **Onde:** parsers/servi√ßos retornam `anyhow`.  
    **Fa√ßa:** Crie `ai_nrf1_errors` (enum). Mapear todos os erros p√∫blicos para este enum (c√≥digo + descri√ß√£o).
7.  **DID/KID sem verifica√ß√£o ASCII/NFC**  
    **Onde:** camadas de rede/registry.  
    **Fa√ßa:** `ensure_ascii()` + NFC obrigat√≥rios para DID/KID; rejeite fora do ASCII b√°sico.
8.  **Sets/Map: KATs insuficientes para ordena√ß√£o por bytes**  
    **Onde:** testes diferenciais limitados.  
    **Fa√ßa:** Adicione casos com itens heterog√™neos e chaves NFC vs NFD. Garanta ordena√ß√£o por **bytes ai-nrf1**, n√£o por string.
9.  **AWS SDK behavior-version**  
    **Onde:** `crates/ubl-storage`.  
    **Fa√ßa:** Use `aws_config::load_defaults` com **behavior-version** fixado/documentado.
10.  **CLI ainda fala termos antigos**  
    **Onde:** `cli/nrf1/src/main.rs`.  
    **Fa√ßa:** Help: ‚Äúencode/decode **ai-nrf1 (UBL-Byte)**‚Äù; nota: ‚ÄúJSON √© view; hash √© sobre bytes ai-nrf1‚Äù.
11.  **`reasoning-bit` sem fronteira de serializa√ß√£o**  
    **Onde:** `crates/reasoning-bit`.  
    **Fa√ßa:** Bloqueie serializa√ß√£o por padr√£o; quando habilitar, converta **via œÅ**, sem floats.
12.  **Falta KAT para bytes vazios**  
    **Onde:** `tests/vectors`.  
    **Fa√ßa:** Adicione `bytes_empty.hex` + JSON-view correspondente; cubra no CI.
13.  **Hex sem for√ßa de paridade/min√∫sculo nas rotas**  
    **Onde:** `services/registry/src/routes/receipts.rs`.  
    **Fa√ßa:** Use util do item (4) e normalize a sa√≠da para min√∫sculo.
14.  **Docs internas com ‚ÄúNRF-1.1‚Äù**  
    **Onde:** READMEs/trechos do zip.  
    **Fa√ßa:** Atualize para **ai-nrf1 / ai-json-nrf1 / ubl-byte / ubl-json** (e exemplos/hex).
15.  **Mistura de structs can√¥nicas vs view**  
    **Onde:** paths que serializam `Value` direto para JSON.  
    **Fa√ßa:** Separe tipos: `AiNrf1Value` (bin√°rio) vs `UblJsonView` (textual). Converta s√≥ por `to_json_view()/from_json_view()`.

Testes que devem passar (aceite)
--------------------------------

*   **KAT ai-nrf1:** round-trip determin√≠stico; rejeita UTF-8 inv√°lido, NotNFC, BOM, floats.
*   **Diff Python‚ÜîRust:** sets/maps heterog√™neos; bytes vazios; ordena√ß√£o por **bytes**.
*   **View JSON:** `b3:`/`b64:` corretos; parse valida antes de materializar.
*   **CLI:** help atualizado; encode/decode/hash/verify OK.
*   **Rotas:** rejeitam hex inv√°lido; normalizam CIDs; DID/KID ASCII-only + NFC.
*   **Erros:** enum √∫nico em toda borda p√∫blica.
*   **AWS:** behavior-version fixado sem warnings deprecados.

Sa√≠da esperada
--------------

1.  Patch aplicando itens 1, 3‚Äì5, 10, 12‚Äì13, 15.
2.  Issues abertas para 2, 7‚Äì9, 11, 14 (separando esfor√ßo por crate).
3.  Relat√≥rio curto: arquivos tocados, novos testes, e checklist ‚úì/‚úó.

* * *

## Prompt:
Complicada essa arquitetura

## Response:
Total ‚Äî d√° pra simplificar sem perder poder. Vou te dar o ‚Äúmapa de bolso‚Äù e um caminho m√≠nimo pra rodar tudo sem a cabe√ßa explodir. üòâ

Mapa mental (5 pe√ßas, uma linha reta)
=====================================

1.  **ai-nrf1 (bytes)** ‚Üí formato bin√°rio can√¥nico. ‚ÄúA verdade s√£o os bytes.‚Äù
2.  **View (ai-json-nrf1 / ubl-json)** ‚Üí s√≥ uma _renderiza√ß√£o_ dos bytes (b3:/b64:), pra humanos/LLMs.
3.  **Capsule (ubl-capsule v1)** ‚Üí `{hdr, env, id, seal, receipts[]}` onde:
    *   `env` = carga de neg√≥cio (ATTEST/EVAL/TRANSACT) **sem** rede/roteamento.
    *   `id` = `blake3( ai-nrf1(capsule \ {id, seal.sig, receipts[*].sig}) )`.
    *   `seal` assina `{domain,id,hdr,env}`.
    *   `receipts[]` = hops encadeados (n√£o tocam no seal).
4.  **SIRP (hops)** ‚Üí INTENT/RESULT/DELIVERY/EXECUTION como _receipts_ append-only.
5.  **Acts (3)** ‚Üí ATTEST / EVALUATE / TRANSACT. S√≥ mudam o _shape_ de `env` e as _policies_. O resto √© igual.

Fluxo fim-a-fim (7 passos)
==========================

1.  App monta `env` (um dos 3 acts).
2.  Converte p/ **ai-nrf1** ‚Üí bytes can√¥nicos.
3.  Calcula `id` (exclui `id` e assinaturas).
4.  Faz `seal` (Ed25519/Dilithium3) sobre `{domain,id,hdr,env}`.
5.  (Rede) adiciona `receipt` por hop: assina `{of:id, prev, kind, node, ts}`.
6.  Verificar = recomputar `id`, checar `seal`, validar cadeia de `receipts`.
7.  Exibir = View JSON (ai-json-nrf1/ubl-json) ‚Äî **nunca** assinar a view.

MVP de 1 semana (corte que entrega valor)
=========================================

**Objetivo:** criar, assinar, encadear e verificar c√°psulas; CLI + testes.  
**S√≥ 4 m√≥dulos e acabou:**

**A. Core bytes (ai-nrf1)**

*   Encoder/decoder (map ordenado por bytes, varint minimal, sem float, NFC, bytes puros).
*   KATs: strings NFC/BOM, sets/maps heterog√™neos, bytes vazios.

**B. View (ai-json-nrf1)**

*   `to_json/from_json` com `b3:`/`b64:` + valida√ß√£o ASCII/NFC.
*   Erros unificados (enum).

**C. Capsule**

*   `capsule_id()`, `capsule_sign()`, `capsule_verify()`.
*   `hdr.src/dst` ASCII-only; `nonce` 16B; `exp` em nanos.

**D. SIRP receipts**

*   `add_receipt(kind,node,ts)`, `verify_chain()`.
*   `prev = blake3(payload_sem_sig)`. Remo√ß√£o/reordena√ß√£o ‚Üí erro.

**Ferramentas**

*   CLI: `cap canon|hash|sign|verify|to-json|from-json|receipt add`.
*   Testes integra√ß√£o: ATTEST‚ÜíEVAL com `pipeline_prev`, bytes vazios, ordering e cadeia de hops.

Interfaces m√≠nimas (para guiar a implementa√ß√£o)
===============================================

```rust
// A
fn ainrf1_encode(v: &Value) -> Vec<u8>;
fn ainrf1_decode(b: &[u8]) -> Result<Value>;

// B
fn to_json_view(v: &Value) -> serde_json::Value;
fn from_json_view(j: &serde_json::Value) -> Result<Value>;

// C
fn capsule_id(c: &Capsule) -> [u8;32]; // exclui id/seal.sig/receipts[*].sig
fn capsule_sign(c: &mut Capsule, key: &SigningKey) -> Result<()>;
fn capsule_verify(c: &Capsule, pk: &VerifyKey) -> Result<()>;

// D
fn receipt_add(c: &mut Capsule, hop: Hop, key: &SigningKey) -> Result<()>;
fn receipts_verify(c: &Capsule) -> Result<()>;
```

Testes obrigat√≥rios (matam 90% dos bugs)
========================================

*   **Canonicidade:** `ainrf1_encode(decode(encode(x)))` id√™ntico (sets/maps/bytes vazios).
*   **View:** `from_json_view(to_json_view(x))` id√™ntico; rejeita float/NotNFC/BOM.
*   **ID:** adicionar/remover `receipts` **n√£o** muda `id`; mexer em `env/hdr` muda.
*   **Seal:** qualquer tamper em `{domain,id,hdr,env}` falha.
*   **Hops:** cadeia quebra se reordenar/remover/alterar `prev/of/sig`.
*   **Acts:** 1 caso de cada (ATTEST/EVAL/TRANSACT) passando; ASK exige `links.prev`; ACK/NACK exigem `evidence`.

Guardrails anti-complexidade
============================

*   Assine/hasheie **s√≥** bytes ai-nrf1.
*   `env` nunca l√™ `hdr`; policies s√≥ veem `env`.
*   DID/KID ASCII-only + Strings NFC.
*   Um √∫nico enum de erros na borda p√∫blica.
*   Nomenclatura fixa: **ai-nrf1**, **ai-json-nrf1** (norma); **ubl-byte**, **ubl-json** (marca).

Se quiser, eu te corto um patch com esse MVP agora mesmo (m√≥dulos, stubs e 6 testes chave) ‚Äî j√° deixa a c√°psula v1 respirando em produ√ß√£o. üöÄ

## Prompt:
No final vira isso que eu te mandei..

## Response:
Sim ‚Äî o destino √© exatamente o que voc√™ descreveu. ‚úÖ  
O ‚Äúmapa de bolso‚Äù que propus converge 1:1 pro artefato final (UBL Capsule v1) com **ai-nrf1** (verdade bin√°ria), **ai-json-nrf1** (view), **id/ seal/ receipts encadeados** e os 3 **Acts**.

Aqui vai o alinhamento direto ‚Üí resultado final:

*   **ai-nrf1 (can√¥nico, 1 byte/1 hash)** ‚Üí encoder/decoder determin√≠stico; tudo que √© prova/ID nasce desses bytes.
*   **ai-json-nrf1 (view)** ‚Üí apenas renderiza√ß√£o com `b3:`/`b64:`; valida NFC/ASCII; nunca assinado.
*   **UBL Capsule v1** ‚Üí `{hdr, env, id, seal, receipts[]}`
    *   `id = blake3(ai-nrf1(capsule \ {id, seal.sig, receipts[*].sig}))`
    *   `seal.sig = sign(blake3(ai-nrf1({domain,id,hdr,env})))`
    *   `receipts[]`: `{of=id, prev, kind, node, ts, sig}` (cadeia append-only)
*   **SIRP** mapeado em `receipts` (INTENT/RESULT/DELIVERY/EXECUTION).
*   **Acts (ATTEST / EVALUATE / TRANSACT)** s√≥ alteram o shape de `env` e as policies; o resto √© id√™ntico.

O que fecho agora (pronto pra commit)
=====================================

1.  **Canon/NRF**
    *   Map ordenado por bytes, varint minimal, strings NFC/ASCII-only (DIDs/KIDs), sem float.
    *   Bytes vazios aceitos. KATs (NFC, BOM, varint minimal).
2.  **View (ai-json-nrf1)**
    *   `to_json/from_json` com `b3:`/`b64:` e erros padronizados.
    *   Idempot√™ncia JSON‚ÜîNRF.
3.  **ID/Seal**
    *   ID exclui `id`, `seal.sig`, `receipts[*].sig`.
    *   Seal com `domain="ubl-capsule/1.0"`, `scope="capsule"`, `aud==hdr.dst` (se presente).
    *   Tamper em `{domain,id,hdr,env}` ‚Üí `Err.Seal.BadSignature`.
4.  **Receipts (hops)**
    *   `prev = blake3(ai-nrf1(payload_sem_sig))`; ordem e integridade verificadas.
    *   Anti-replay: `(hdr.src, hdr.nonce)` cache + `hdr.exp` (epoch-nanos).
5.  **Invariantes de env**
    *   `decision.verdict ‚àà {ACK,NACK,ASK}`; **ASK ‚áí links.prev obrigat√≥rio**; **ACK/NACK ‚áí evidence presente (pode vazia)**.
    *   Policies s√≥ leem `env`; runtime n√£o acessa `hdr`.
6.  **CLI**
    *   `ubl cap canon|hash|sign|verify|to-json|from-json|receipt add`
    *   Integra√ß√£o: round-trip + pipeline\_prev (ATTEST‚ÜíEVAL) + cadeia de hops.

Se quiser, j√° te entrego estes commits como patch √∫nico (m√≥dulos, schemas e testes de integra√ß√£o) ‚Äî √© s√≥ aplicar e rodar a su√≠te. üöÄ

## Prompt:
o mapa mental que tem que fazer eh mais complexo que os outros projetos

## Response:
Total. Esse mapa mental precisa abra√ßar **proto + runtime + prova + produto** ‚Äî mais denso que os outros. Bora te dar um ‚Äúesqueleto can√¥nico‚Äù que voc√™ pode colar num editor (Mermaid/Obsidian/VSCode) e j√° renderizar. Vou te entregar 3 coisas: (1) mind map das pe√ßas, (2) fluxo ponta-a-ponta, (3) checklist de verifica√ß√£o. Depois √© s√≥ especializar por produto. üöÄüß†

1) Mapa mental ‚Äî vis√£o √∫nica do stack
=====================================

```mermaid
mindmap
  root((UBL Capsule v1))
    AI-NRF1:::canon
      Regras:: NFC/UTF-8 / sem float / varint minimal / map ordenado
      Tipos:: Int64 / String / Bytes / Array / Map
      Invariantes:: canonicidade / idempot√™ncia
    AI-JSON-NRF1:::view
      View:: b3:<hex> / b64:<...> / n:<int>
      Parser:: valida NFC/ASCII / pro√≠be float
      Idempot√™ncia:: JSON‚ÜîNRF
    Capsule:::caps
      hdr
        src(dst):: DID/KID ASCII
        nonce:: Bytes(16)
        exp:: epoch-nanos
        chan/ts:: opcionais
      env
        v/t:: ai-json-nrf1 / record|bundle|trace
        intent:: ATTEST|EVAL|TRANSACT|BUNDLE|TRACE|QUERY
        decision:: ACK|NACK|ASK
        links:: prev(trace)
        evidence:: cids(urls)
        meta:: app/tenant/user
      id
        regra:: blake3(nrf(capsule \ {id, seal.sig, receipts[*].sig}))
      seal
        domain:: "ubl-capsule/1.0"
        scope:: "capsule"
        aud:: == hdr.dst?
        sig:: Ed25519|Dilithium3
      receipts
        hop:: {of, prev, kind, node, ts, sig}
        cadeia:: append-only / prev = blake3(nrf(payload_sem_sig))
    SIRP:::sirp
      INTENT
      DELIVERY
      EXECUTION
      RESULT
    Acts:::acts
      ATTEST:: exist√™ncia/proveni√™ncia
      EVALUATE:: compliance/threshold
      TRANSACT:: autoriza√ß√£o/duas partes
      pipeline_prev:: encadeia atos
    Tooling:::tool
      CLI:: canon|hash|sign|verify|to-json|from-json|receipt add
      KATs:: unicode/varint/bytes vazios
      Bundle offline:: manifest + policy + EER
classDef canon fill:#cfe9,stroke:#0a5,stroke-width:2px
classDef view fill:#eef7ff,stroke:#06c,stroke-width:2px
classDef caps fill:#ffe,stroke:#cc8,stroke-width:2px
classDef sirp fill:#fde,stroke:#d26,stroke-width:2px
classDef acts fill:#f3f,stroke:#909,stroke-width:2px,color:#fff
classDef tool fill:#eee,stroke:#666,stroke-width:1.5px
```

2) Fluxo ponta-a-ponta (quem toca o qu√™)
========================================

```mermaid
flowchart LR
  subgraph Author["Wrapper/Servi√ßo"]
    A1[Montar hdr+env]
    A2[Compute id = blake3(nrf(...))]
    A3[Seal = sign(blake3(nrf{domain,id,hdr,env}))]
    A4[(Opc. receipts=[])]
  end
  subgraph Network["Transporte/Relay"]
    N1[Validar seal/exp]
    N2[Emitir receipt hop<br/>prev = blake3(nrf(payload_sem_sig))]
  end
  subgraph Verifier["Cliente/Auditor"]
    V1[Recalcular id]
    V2[Verificar seal domain/scope/aud]
    V3[Checar cadeia receipts prev‚Üí...]
    V4[Entregar env p/ TDLN]
  end

  A1-->A2-->A3-->A4-->N1
  N1-->N2-->Verifier
  Verifier-->V1-->V2-->V3-->V4
```

3) Checklist de verifica√ß√£o (pra n√£o se perder) ‚úÖ
=================================================

*   **Canon (ai-nrf1)**  
    \[ \] Map ordenado por bytes UTF-8  
    \[ \] varint32 minimal; rejeita non-minimal  
    \[ \] Strings NFC; ASCII-only p/ DID/KID; sem BOM  
    \[ \] Aceita `Bytes("")` (vazio)
*   **View (ai-json-nrf1)**  
    \[ \] `to_json/from_json` idempotentes  
    \[ \] Prefixos `b3:`/`b64:`/`n:` corretos  
    \[ \] Erros normativos (NotNFC, InvalidUTF8, FloatForbidden, ‚Ä¶)
*   **ID**  
    \[ \] Exclui `id`, `seal.sig`, `receipts[*].sig`  
    \[ \] Alterar `env/hdr` ‚áí muda `id`; anexar/remover receipt ‚áí **n√£o** muda `id`
*   **Seal**  
    \[ \] `domain="ubl-capsule/1.0"` e `scope="capsule"` exigidos  
    \[ \] `aud == hdr.dst` quando presente  
    \[ \] Ed25519/Dilithium3 verificados sobre bytes NRF
*   **Receipts (hops)**  
    \[ \] `of == capsule.id`  
    \[ \] `prev = blake3(nrf(payload_sem_sig))`  
    \[ \] Ordem re-constitu√≠da / reordena√ß√£o detectada  
    \[ \] Anti-replay `(hdr.src, hdr.nonce)` + `hdr.exp` respeitado
*   **Env invariantes**  
    \[ \] `verdict ‚àà {ACK,NACK,ASK}`  
    \[ \] `ASK ‚áí links.prev` obrigat√≥rio  
    \[ \] `ACK|NACK ‚áí evidence` presente (pode vazia)  
    \[ \] Policies s√≥ leem `env`; runtime **n√£o** acessa `hdr`
*   **Acts & Pipeline**  
    \[ \] `pipeline_prev` encadeia ATTEST‚ÜíEVAL etc.  
    \[ \] Testes de dois passos verificam `prev`/CID
*   **CLI/Bundle**  
    \[ \] `canon|hash|sign|verify|to-json|from-json|receipt add` funcionam  
    \[ \] Vetores KAT (unicode, varint, bytes vazios, mapas ordenados)  
    \[ \] Bundle offline verifica 100% sem rede

* * *

Se quiser, eu j√° **gero o mesmo mapa** especializado por ‚ÄúAPI Receipt Gateway‚Äù e por ‚ÄúAI Model Passport‚Äù, com os n√≥s do `env.intent`/`decision`/`evidence` preenchidos ‚Äî assim voc√™ tem **mapas por produto** na mesma gram√°tica. Quer que eu te entregue essas duas varia√ß√µes agora? üòÑüß©

## Prompt:
Tem BASE, M√ìDULOS e PRODUTOS, esse √© o ecossistema completo. 

BASE - bytes
M√ìDULOS - c√≥digo "normal"

1 binario com m√≥dulos featured flags

PRODUTOS - cada um √© um bin√°rio e em reposit√≥rios diferentes

√© isso?

## Response:
Sim ‚Äî essa decomposi√ß√£o fecha redondo. üëá

BASE ‚Üí M√ìDULOS ‚Üí PRODUTOS
=========================

1) BASE (bytes; ‚Äúverdade √∫nica‚Äù)
--------------------------------

*   **Nome**: `ai-nrf1` (bytecanon) + `ai-json-nrf1` (view determin√≠stica).
*   **Fun√ß√£o**: encoder/decoder NRF; view JSON‚ÜîNRF; hashing (BLAKE3); verifica√ß√£o de seal; receipts encadeadas.
*   **Contrato**: tipos bin√°rios (Bytes/Int64/String), NFC/UTF-8, varint minimal, map ordenado, regras normativas e erros.
*   **Entrega**: crates/libs puras (sem I/O), + um **bin√°rio utilit√°rio** (ex.: `ubl-byte`) s√≥ pra tooling (canon|hash|sign|verify).

> A BASE n√£o ‚Äúopina‚Äù sobre dom√≠nio. S√≥ bytes, canonicidade, id, seal, receipts. Tudo que est√° acima _consome_ a BASE.

* * *

2) M√ìDULOS (c√≥digo ‚Äúnormal‚Äù com feature flags)
----------------------------------------------

*   **O que s√£o**: camadas de aplica√ß√£o em cima da BASE: SIRP, acts (ATTEST/EVALUATE/TRANSACT), policy-packs, enrichment (badge/pdf/status/webhook), intake adapters (document/event/transaction), bundle offline, etc.
*   **Formato**: **um √∫nico bin√°rio** (ex.: `tdln`) com **feature flags** habilitando m√≥dulos:
    *   `sirp`, `acts-attest`, `acts-evaluate`, `acts-transact`
    *   `enrich-badge`, `enrich-pdf`, `enrich-status`, `enrich-webhook`, `enrich-ghost`
    *   `intake-document`, `intake-event`, `intake-transaction`
    *   `bundle-offline`, `permit`, `consent-kofn`, etc.
*   **Por qu√™**: 1 execut√°vel = DX mais simples, footprint controlado por features, reuso m√°ximo, menor superf√≠cie de manuten√ß√£o.
*   **Contrato est√°vel**: M√ìDULOS **nunca** quebram a BASE; interagem via tipos/traits est√°veis (ex.: `CanonValue`, `Capsule`, `Receipt`, `Enrichment`).

Exemplo (Cargo.toml do ‚Äúbin√°rio de m√≥dulos‚Äù):

```toml
[package]
name = "tdln"
version = "0.1.0"
edition = "2021"

[dependencies]
ai-nrf1 = { path = "../impl/rust/ai-nrf1" }
ai-json-nrf1 = { path = "../impl/rust/ai-json-nrf1" }
sirp = { path = "../modules/sirp", optional = true }
acts = { path = "../modules/acts", optional = true, features = ["attest","evaluate","transact"] }
enrich = { path = "../modules/enrich", optional = true }
bundle = { path = "../modules/bundle", optional = true }

[features]
default = ["sirp","acts","enrich","bundle"]
minimal = []
prod_api_gateway = ["sirp","acts","enrich","bundle"]
prod_ai_passport = ["acts","enrich","bundle"]
```

* * *

3) PRODUTOS (cada um seu bin√°rio e reposit√≥rio)
-----------------------------------------------

*   **O que s√£o**: ‚Äúembalagens‚Äù de dom√≠nio: API Receipt Gateway, AI Model Passport, Notarize-and-Prove, etc.
*   **Reposit√≥rio pr√≥prio** por produto (isolamento de ciclo de release, licen√ßas, branding, SLA).
*   **Bin√°rio pr√≥prio** por produto (ex.: `receipt-gw`, `ai-passport`), constru√≠do **em cima do bin√°rio de M√ìDULOS** (link est√°tico/din√¢mico) **ou** usando os crates dos m√≥dulos.
*   **Manifesto** por produto (JSON/YAML) declarando: acts, policy-packs, proof-level, enrichments, billing axis, consent k-of-n, rotas/CLI.

Exemplo de depend√™ncia (Cargo.toml do produto):

```toml
[package]
name = "receipt-gw"
version = "0.1.0"
edition = "2021"

[dependencies]
tdln = { git = "https://github.com/org/tdln", tag = "v0.3.0", features = ["sirp","acts","enrich","bundle"] }
ai-nrf1 = { git = "https://github.com/org/ai-nrf1", tag = "v1.1.0" }
ai-json-nrf1 = { git = "https://github.com/org/ai-nrf1", tag = "v1.1.0" }
```

* * *

Topologia de reposit√≥rios (sugest√£o)
------------------------------------

*   **monorepo-core** (BASE + M√ìDULOS)
    *   `impl/rust/ai-nrf1` (BASE)
    *   `impl/rust/ai-json-nrf1` (BASE-view)
    *   `modules/sirp`, `modules/acts`, `modules/enrich`, `modules/bundle` (M√ìDULOS)
    *   `bin/tdln` (bin√°rio √∫nico com feature flags)
    *   `schemas/‚Ä¶`, `specs/‚Ä¶`, `tests/‚Ä¶` (KATs, integra√ß√£o)
*   **produtos/** (multirepo, um por produto)
    *   `receipt-gw/` ‚Üí bin `receipt-gw`
    *   `ai-passport/` ‚Üí bin `ai-passport`
    *   `notarize-prove/` ‚Üí bin `notarizer`
    *   ‚Ä¶ (cada um com seu CI, vers√£o, README, licen√ßa)

> Se preferir, d√° pra come√ßar ‚Äútudo em monorepo‚Äù e, quando o produto estabilizar, **split** para repo pr√≥prio mantendo tags/refs da BASE e M√ìDULOS.

* * *

Interfaces e estabilidade (regra de ouro)
-----------------------------------------

*   **BASE**: **SEMVER MAJOR super est√°vel** (v1.x). Mudou o wire/bytes? novo major.
*   **M√ìDULOS**: **SEMVER normal**; sempre compat√≠veis com BASE ‚Äú^1.x‚Äù.
*   **PRODUTOS**: travam vers√µes de BASE/M√ìDULOS via lockfile e ‚Äúrelease train‚Äù.

* * *

Execu√ß√£o/empacotamento
----------------------

*   **Dev local**: `tdln` com features + manifesto do produto (`product.json`) gera servi√ßo ‚Äúpreview‚Äù.
*   **Release**: produto compila bin pr√≥prio (linka crates de M√ìDULOS) com configs/manifesto embarcados.
*   **Air-gapped**: sempre dispon√≠vel via **bundle offline** (m√≥dulo).

* * *

Testes/CI (matriz m√≠nima)
-------------------------

*   **BASE**: KATs (unicode/varint/map ordenado/bytes vazios), fuzz, invariantes de ID/Seal/Receipts.
*   **M√ìDULOS**: integra√ß√£o (acts, SIRP, enrichments, bundle); pipeline\_prev; consent k-of-n; permit.
*   **PRODUTOS**: e2e por manifesto (ATTEST‚ÜíEVALUATE‚ÜíTRANSACT), webhooks/badges/PDF, offline verify.

* * *

Pr√≥s x Contras desse desenho
----------------------------

**Pr√≥s**

*   Camada de bytes independente ‚Üí prova e canonicidade garantidas.
*   1 bin√°rio de M√ìDULOS com features ‚Üí simplicidade operacional + reuso m√°ximo.
*   Produtos isolados em reposit√≥rios ‚Üí governan√ßa e GTM limpos.

**Contras**

*   Coordena√ß√£o de vers√µes entre PRODUTOS e M√ìDULOS (mitigado com release train e tags).
*   Bin√°rio √∫nico de m√≥dulos pode crescer (mitigado por features e LTO).

* * *

TL;DR
-----

*   **Sim**, √© isso:
    *   **BASE** (ai-nrf1/ai-json-nrf1): bytes & canonicidade.
    *   **M√ìDULOS**: **um bin√°rio** com feature flags (SIRP/acts/enrich/bundle/‚Ä¶).
    *   **PRODUTOS**: **um bin√°rio por produto** em **reposit√≥rios separados**, montados sobre os M√ìDULOS (e, portanto, sobre a BASE).

Se quiser, te passo um **esqueleto de `product.json`** e um **Makefile** padr√£o p/ produto (build, test, bundle-offline, verify) ‚Äî fica plug-and-play. üí•

## Prompt:
Como √© a comunica√ß√£o BASE - M√ìDULOS? E a M√ìDULOS - PRODUTO?

Existe um centro de comando que movimenta m√≥dulos que cada produto precisa ou cada produto vai chamando e compondo, m√≥dulos est√°ticos.

## Response:
√ìtima pergunta, Dan ‚Äî √© aqui que a arquitetura ‚Äúencaixa‚Äù de verdade. Vou te dar o desenho objetivo, com modos de opera√ß√£o e trade-offs. üí°

Como as camadas falam entre si
==============================

BASE ‚Üî M√ìDULOS (sempre **in-process**)
--------------------------------------

*   **Contrato**: tipos e fun√ß√µes puras, sem I/O, determin√≠sticas.
*   **Quem chama quem**: os **M√ìDULOS** importam a **BASE** como lib.
*   **O que trafega**: estruturas can√¥nicas:
    *   `CanonValue` (√°rvore NRF), `Bytes` (fixos), `Capsule`, `Receipt`.
    *   `encode()/decode()`, `cid()`, `sign()/verify()`, `receipt_chain_verify()`.
*   **Garantias**: sem side effects; tudo que impacta hash/assinatura fica na BASE.

Pseudoc√≥digo (Rust) da fronteira:

```rust
// BASE
pub struct CanonValue(/*...*/);
pub struct Capsule { pub v: String, pub id: [u8;32], pub hdr: CanonValue, pub env: CanonValue, pub seal: CanonValue, pub receipts: Vec<CanonValue> }

pub fn encode(v:&CanonValue)->Vec<u8>;
pub fn decode(bytes:&[u8])->Result<CanonValue>;
pub fn cid(v:&CanonValue)->[u8;32];                    // BLAKE3 sobre bytes NRF
pub fn capsule_id(c:&Capsule)->[u8;32];                // exclui id/sigs
pub fn capsule_sign(c:&mut Capsule, key:&KeyPair)->(); // scope/domain
pub fn capsule_verify(c:&Capsule, pk:&PubKey)->Result<()>;
pub fn receipts_verify(c:&Capsule)->Result<()>;
```

Os M√ìDULOS **n√£o reimplementam nada** de canonicidade; s√≥ **consomem**.

* * *

M√ìDULOS ‚Üî PRODUTOS (duas formas poss√≠veis)
------------------------------------------

### Modo A ‚Äî **Composi√ß√£o est√°tica** (default)

*   **Como**: cada **PRODUTO** linka o **bin√°rio de M√ìDULOS** (ou crates) com **feature flags**.
*   **Quem orquestra**: o pr√≥prio bin√°rio do **PRODUTO** chama e comp√µe os m√≥dulos necess√°rios.
*   **Config**: manifesto do produto (ex.: `product.json`) habilita acts, proof level, enrichments, policy packs, consent k-of-n, etc.
*   **Pr√≥s**: simples, reprodut√≠vel, determin√≠stico (√≥timo para P0/P1).
*   **Contras**: trocar m√≥dulo = novo build do produto (ok para a maioria dos casos early).

Fluxo t√≠pico:

```
[Produto bin√°rio]
   ‚Üí intake (document/event/transaction)
   ‚Üí acts.{attest|evaluate|transact}
   ‚Üí policies (packs = dados)
   ‚Üí proof_level {receipt|sirp|bundle}
   ‚Üí enrichments {badge/pdf/status/webhook}
   ‚Üí BASE (encode/cid/sign/verify) em cada etapa cr√≠tica
```

### Modo B ‚Äî **Control Plane** (opcional, multi-produto)

*   **O que √©**: um servi√ßo ‚Äúcentro de comando‚Äù que **provisiona dados** aos produtos:
    *   registry de **policy packs**, **keys**, **consent queues (k-of-n)**, **permits**, **enrich configs**.
*   **Como fala**: HTTP/gRPC (SDK leve) ‚Äî mas **o c√°lculo can√¥nico** continua **in-process** no produto/m√≥dulo.
*   **Pr√≥s**: troca de packs/rotas/consent **sem rebuild** do produto; opera√ß√µes centralizadas.
*   **Contras**: adiciona um componente operacional (infra).

**Importante**: o Control Plane **n√£o executa pol√≠ticas nem re-serializa**; ele **entrega dados/ordens**. O produto continua chamando os M√ìDULOS localmente, que por sua vez chamam a BASE para canonicidade/assinatura.

* * *

Recomenda√ß√µes pr√°ticas
======================

1.  **Come√ßo (P0‚ÄìP1)**: **Modo A (est√°tico)**  
    Produto chama m√≥dulos diretamente; m√≥dulos chamam BASE. Tudo em processo; manifesto guia a composi√ß√£o. Determinismo m√°ximo.
2.  **Escala (multi-times, multi-produtos)**: anexar **Control Plane** (Modo B)
    *   Ele **desbloqueia**: troca de policy packs por vers√£o, rota√ß√£o de chaves, filas de consentimento, emiss√£o de permits, templates de enrichments.
*   Continue mantendo **BASE in-process** nos produtos: hashes e assinaturas nunca saem do determinismo local.

* * *

Interfaces claras (para n√£o ter atrito)
=======================================

API entre Produto ‚Üî M√≥dulos (em c√≥digo)
---------------------------------------

```rust
// M√ìDULOS exp√µem traits est√°veis
pub trait Intake { fn normalize(&self, json: &serde_json::Value) -> CanonValue; }
pub trait Act    { fn run(&self, env: &CanonValue) -> ActResult; } // env somente
pub trait Proof  { fn emit(&self, c:&mut Capsule, level: ProofLevel) -> (); }
pub trait Enrich { fn render(&self, c:&Capsule) -> Vec<Artifact>; }

pub struct ActResult { pub verdict: Verdict, pub poi: Option<CanonValue>, pub metrics: CanonValue }
```

*   `env` √© a √∫nica coisa que **Acts/Policies** enxergam (LLM-first).
*   `hdr` √© de transporte (roteamento/expira√ß√£o); os Acts **n√£o** tocam.

API Control Plane (opcional)
----------------------------

*   `GET /policy-packs?domain=...&version=...` ‚Üí blobs (dados, n√£o c√≥digo)
*   `POST /consent/tickets` ‚Üí abre/consulta k-de-n
*   `POST /permits` ‚Üí assina permit (PK do dom√≠nio)
*   `GET /enrich/templates` ‚Üí configura√ß√µes (p.ex. mask/redact do ghost)

Produtos **consomem** esses dados e executam localmente via m√≥dulos.

* * *

Quando usar cada modo
=====================

*   **Produtos internos, time √∫nico, release r√°pido** ‚Üí **Est√°tico**.
*   **Clientes m√∫ltiplos, compliance/rotas mudando toda semana** ‚Üí **\+ Control Plane**.
*   **Cen√°rios air-gapped** ‚Üí sempre **in-process**; Control Plane vira **mirror offline** (dados versionados).

* * *

TL;DR
=====

*   **BASE ‚á¢ M√ìDULOS**: chamada **in-process**, lib pura (bytes/canon/hash/sign/verify).
*   **M√ìDULOS ‚á¢ PRODUTO**: por padr√£o **est√°tico** (produto comp√µe); opcional **Control Plane** que **provisiona dados** (packs/keys/consent/permits) sem executar pol√≠ticas.
*   **Hash/assinatura** nunca saem do processo local ‚Äî canonicidade continua garantida.

Se quiser, eu te deixo um **esqueleto do Control Plane** (endpoints + esquema das mensagens) e um **manifesto `product.json`** modelo que o bin de M√ìDULOS l√™ pra montar o pipeline. Quer que eu j√° te entregue esses dois arquivos? üöÄ

## Prompt:
Como a tecnologia do pr√≥prio produto (LLM-Engine e LLM-smart, que s√£o composi√ß√µes tdln-llm premium ou opensource para fins de performance e custo) podem ajudar nestes arranjos?

## Response:
Perfeito, Dan! D√° pra usar **LLM-Engine** e **LLM-smart** como ‚Äúturbinas‚Äù do ecossistema sem quebrar o determinismo da BASE. A sacada √©: **LLM sugere / transforma / enriquece**, mas **s√≥ vira verdade** depois que passa por **œÅ‚Üíai-nrf1** (canon), **hash**, e eventualmente **consent/permit**. Abaixo vai o mapa pr√°tico de onde eles entram e como estruturamos isso.

Onde cada pe√ßa atua
===================

1) BASE (bytes, canonicidade, provas) ‚Äî ‚Äúzona zero‚Äù
---------------------------------------------------

*   **Regra**: nada de LLM aqui. Somente fun√ß√µes puras: `encode/decode`, `cid`, `sign/verify`, receipts/hops.
*   **Como usar LLM** em torno da BASE: ele **gera propostas** (texto, JSON) que viram **inputs** de M√ìDULOS; s√≥ ap√≥s normalizar em **ai-nrf1** isso entra no circuito com CIDs/assinaturas.

2) M√ìDULOS (c√≥digo ‚Äúnormal‚Äù) ‚Äî ‚Äúonde o LLM brilha‚Äù
--------------------------------------------------

Crie m√≥dulos LLM-first, todos trabalhando **apenas no `env`** (nunca no `hdr`), com sa√≠das sempre **canoniz√°veis**:

1.  **llm\_mapper**
    *   Tarefa: mapear artefatos livres ‚Üí **env** can√¥nico (extra√ß√£o de campos, normaliza√ß√£o de unidades, deduplica√ß√£o sem√¢ntica).
    *   Ex.: SBOM/relat√≥rios ‚Üí `env.ctx` + `env.evidence.cids`.
    *   **Contrato**: recebe blobs/JSON, produz **`CanonValue`** (ai-json-nrf1).
    *   **Fail-safe**: se amb√≠guo ‚áí retorna **ASK** com PoI do que falta.
2.  **llm\_policy\_assistant**
    *   Tarefa: sintetizar/atualizar **policy units** (TDLN) a partir de requisitos em linguagem natural, e sugerir **test vectors**.
    *   **Pipeline**: NL ‚Üí rascunho TDLN ‚Üí **verifica√ß√£o est√°tica** (sem√¢ntica, tipos, faixas) ‚Üí **KATs** ‚Üí PR no reposit√≥rio de packs.
    *   **Fail-safe**: proposta nunca √© ativa sem **consent k-of-n** + `permit`.
3.  **llm\_enricher**
    *   Tarefa: gerar **badge/status page/ghost explanations** leg√≠veis, sum√°rios, ‚Äúadverse action notices‚Äù, etc.
    *   Entrada: **receipt** + `env.decision` + `poi`.
    *   Sa√≠da: artefatos **derivados** (HTML/PDF), nunca mudam bytes can√¥nicos.
4.  **llm\_guard**
    *   Tarefa: red-teaming offline de policies e prompts (fuzz sem√¢ntico), detec√ß√£o de confus√°veis, **simula√ß√£o** de bypass, gera√ß√£o de **contra-exemplos**.
    *   Produz: novos **KATs** e casos de teste.
5.  **llm\_router (LLM-smart)**
    *   Tarefa: **rotear** chamadas LLM entre **premium** e **OSS** por **custo/lat√™ncia/risco**.
    *   Estrat√©gias:
        *   **Cache por CID** (prompt/result): `key = blake3(ai-nrf1(prompt))`.
        *   **Fall-back**: draft com OSS ‚Üí refino com premium **s√≥** se thresholds pedirem.
        *   **Risco**: tarefas ‚Äúdelicadas‚Äù (compliance) sob premium com logs e KATs.
6.  **llm\_retrieval**
    *   Tarefa: RAG sobre **receipts, policies e KATs**, indexado por **CID** (sem vazar dados brutos).
    *   Boa p/ explicabilidade e gera√ß√£o de PoIs precisos.

> Todos estes m√≥dulos retornam **`ActResult`** (`ACK/NACK/ASK`, `poi`, `metrics`) e nunca escrevem bytes por conta pr√≥pria ‚Äî isso √© tarefa da BASE.

3) PRODUTOS (bin√°rios) ‚Äî ‚Äúorquestra√ß√£o‚Äù
---------------------------------------

*   **Modo A (est√°tico, recomendado p/ agora)**: cada produto linka os M√ìDULOS via **feature flags** e comp√µe pipeline conforme `product.json`.
*   **Modo B (com Control Plane, mais tarde)**: ele **provisiona dados** (policy packs, chaves, consent queues), mas **execu√ß√£o** continua local (determinismo).

Padr√µes de uso do LLM (seguros e √∫teis)
=======================================

1.  **NL ‚Üí Policy (TDLN) com verifica√ß√£o autom√°tica**

```text
Cliente: ‚ÄúBloquear modelos com >3% toxicidade no ToxiEval; exigir datasheet‚Äù
LLM: gera TDLN + KATs
BASE: valida JSON‚úØAtomic + roda KATs
Consent (k-of-n): aprova mudan√ßa
Permit: assina vers√£o do pack
```

2.  **Explicabilidade / PoI**
    *   NACK/ASK ‚Üí LLM gera texto curto e objetivo citando campos do `env`, sem inventar.
*   **Regra**: PoI sempre tra√ß√°vel para regras e valores (linkados por CID).
    3.  **Mapping & Normalization**
    *   OCR/parse de PDF/planilha, YAML‚ÜíJSON, merge de fontes, resolu√ß√£o de unidades.
*   Output sempre can√¥nico: **ai-nrf1**; nada sai direto do LLM.
    4.  **Custo & Performance (LLM-smart)**
    *   **Cache by CID** (entrada prompt + contexto serializado em ai-nrf1).
*   **Batching** de enriquecimentos (100 decis√µes ‚Üí 100 resumos numa tacada).
*   **Distil**: treine um modelo OSS leve com seus pr√≥prios prompts/outputs (reduz custo).
    5.  **Seguran√ßa / Conformidade**
    *   Prompt-templates versionados ‚Üí **CID** no `env.meta`.
*   **Red-teaming** cont√≠nuo em CI (llm\_guard) antes de liberar novas vers√µes.
*   Pol√≠tica: se incerteza > Œ∏ ‚áí **ASK** (nunca ‚Äúinventar‚Äù ALLOW/DENY).

Fluxos concretos (exemplos)
===========================

A) API Receipt Gateway (TRANSACT)
---------------------------------

1.  **llm\_mapper**: extrai contrato/termos do payload (quando h√° corpo ‚Äúlivre‚Äù).
2.  **policy packs**: autoriza√ß√£o/quotas/shape (n√£o-LLM).
3.  **llm\_enricher**: em NACK/ASK, explica ‚Äúpor que‚Äù/‚Äúo que falta‚Äù.
4.  **BASE**: capsule‚Üíid‚Üíseal; SIRP INTENT/RESULT; hops.
5.  **llm\_router**: premium s√≥ quando precisa explicar casos complexos.

B) AI Model Passport (ATTEST‚ÜíEVALUATE)
--------------------------------------

1.  **llm\_mapper**: l√™ Model Card/benchmarks e normaliza campos.
2.  **llm\_policy\_assistant**: sintetiza regras setoriais (draft); passa por KATs+consent.
3.  **policy packs**: EU AI Act thresholds, documenta√ß√£o, vi√©s.
4.  **llm\_enricher**: gera **badge**, **PDF** e ‚Äúadverse action‚Äù (NACK).
5.  **BASE**: bundle offline + provas.

Contratos e esbo√ßos (sucintos)
==============================

**M√≥dulos (Rust)**

```rust
pub trait Intake { fn normalize(&self, raw: &serde_json::Value) -> CanonValue; }
pub struct ActResult { pub verdict: Verdict, pub poi: Option<CanonValue>, pub metrics: CanonValue }

pub trait Act { fn run(&self, env: &CanonValue) -> ActResult; } // usa s√≥ env
pub trait Enrich { fn render(&self, c:&Capsule) -> Vec<Artifact>; }
```

**LLM-smart (roteador)**

```rust
pub enum Tier { Premium, OSS }
pub struct Route { pub tier: Tier, pub cache_hit: bool }

pub fn route(task: &TaskMeta) -> Route {
    // heur√≠sticas: risco, custo, lat√™ncia, confidencialidade
}
```

**Cache por CID**

```text
cache_key = blake3( ai-nrf1( {prompt, fewshots, context.cids} ) )
```

Regras de ouro (anti-surpresa)
==============================

*   **LLM nunca decide ALLOW/DENY** sozinho; no m√°ximo produz **ASK/PoI**.
*   Tudo que o LLM produzir vira **input** que passa por **ai-nrf1‚Üícid‚Üípermit**.
*   Logs de LLM (prompts/templates) s√£o versionados e referenciados por **CID** no `env.meta`.
*   Dados sens√≠veis: s√≥ via **CIDs** (conte√∫do fora do core).
*   **Ghost**: LLM s√≥ mascara/extrai explica√ß√£o; os bytes de prova v√™m da BASE.

Roadmap turbo (p/ j√° integrar)
==============================

1.  **Criar crates** `llm_mapper`, `llm_enricher`, `llm_policy_assistant`, `llm_guard`, `llm_router`.
2.  Cada m√≥dulo recebe/retorna **CanonValue** e **ActResult**; zero acesso a `hdr`.
3.  **Plugar no primeiro produto** (API Gateway) via feature flags.
4.  Ligar **cache por CID** no `llm_router`.
5.  Subir **KATs** espec√≠ficos de LLM: mapeamento, explicabilidade, policy-draft.
6.  No **Control Plane** (fase 2): endpoints s√≥ de **dados** (packs/keys/consent); execu√ß√£o continua local.

‚Äî

Se quiser, eu j√° te entrego:

*   `product.json` exemplo habilitando **llm\_mapper + llm\_enricher + llm\_router**;
*   um **test harness** que mede custo/lat√™ncia (premium vs OSS) com **cache por CID**;
*   KATs m√≠nimos para **Model Passport** (doc completeness + bias thresholds) e **API Gateway** (shape + quota).

S√≥ falar ‚Äúmanda‚Äù e eu deixo os arquivos prontos pra rodar. üí•

## Prompt:
S√≥ mais uma coisa:

O core dos produtos vai ser a composi√ß√£o de m√≥dulos que podemos chamar de core. Atuam como tamb√©m nos produtos. Eu ia fazer uma pergunta mas eu esqueci, era pra saber se existe m√≥dulo core e m√≥dulo mais geral , to complicando as coisas

## Response:
Thought for 6s

T√° tudo certo, voc√™ n√£o t√° complicando ‚Äî s√≥ precisa de um vocabul√°rio claro. A separa√ß√£o que fecha √© esta aqui üëá

Taxonomia de m√≥dulos (simples e suficiente)
===========================================

1) Core (determin√≠sticos)
-------------------------

**O que s√£o:** blocos reutiliz√°veis, sem I/O externo no caminho cr√≠tico, sempre can√¥nicos (œÅ‚Üíai-nrf1‚Üíbytes).  
**Crit√©rios para ser Core:**

*   usado por ‚â•3 produtos diferentes;
*   depende **apenas** da BASE (bytes, cid, sign/verify, receipts);
*   comportamento puro/determin√≠stico (mesma entrada ‚Üí mesmos bytes/decis√£o);
*   APIs est√°veis (versionadas por CID).

**Exemplos:**

*   `intake-{document|event|transaction}` (normalizadores puros ‚Üí `env` can√¥nico)
*   `permit` (assina/verifica autoriza√ß√£o do ALLOW)
*   `sirp-{capsule,verify}` (INTENT/RESULT + hops, verifica√ß√£o)
*   `canon-{ai-json-nrf1, ubl-json-view}` (valida√ß√£o/normaliza√ß√£o)
*   `enrich-{badge,status,ghost,pdf}` (derivados determin√≠sticos a partir de receipts)
*   `packs-runtime` (executor de policy units; **sem** chamar LLM)

> Pensa nesses como ‚Äúbiblioteca padr√£o‚Äù da plataforma.

2) Domain (m√≥dulos de produto)
------------------------------

**O que s√£o:** pe√ßas espec√≠ficas de dom√≠nio/setor que **montam** um produto. Podem combinar Core + conte√∫do (policies, schemas, KATs).  
**Exemplos:**

*   `domain-api-gateway` (shape/quotas/authorization)
*   `domain-model-passport` (EU AI Act, bias thresholds, doc completeness)
*   `domain-compliance-soc2`, `domain-finra`, `domain-hipaa`
*   `schema.rs / mapper.rs` de cada wrapper

3) Assistive-LLM (opcionais, fora do ‚Äún√∫cleo duro‚Äù)
---------------------------------------------------

**O que s√£o:** aceleradores que **geram/explicam/sugerem**, mas **n√£o** decidem; a verdade volta a ser a BASE.  
**Exemplos:**

*   `llm_mapper` (extrai campos de PDFs/relat√≥rios ‚Üí proposta de `env`)
*   `llm_policy_assistant` (rascunha TDLN + KATs; entra via consent/permit)
*   `llm_enricher` (texto humano de NACK/ASK/PoI, badges descritivos)
*   `llm_router` (premium vs OSS, cache por CID)
*   `llm_guard` (red team sem√¢ntico ‚Üí novos KATs)

> Chame-os de **assistivos** para n√£o confundir com o **Core** determin√≠stico.

* * *

Como compor (sem ‚Äúcentral de comando‚Äù)
======================================

*   **Produtos** s√£o **bin√°rios pr√≥prios** que **linkam** Core + Domain (+ Assistive-LLM se habilitado) via **feature flags**.
*   **Control Plane** (se/quando existir) **distribui packs, chaves e consent**; **n√£o** orquestra execu√ß√£o (evita acoplamento e preserva determinismo).
*   Fluxo padr√£o:
    1.  Domain/intake prepara `env` (pode usar `llm_mapper` como _proposta_).
    2.  Core valida (œÅ‚Üíai-nrf1), decide (policies), **gera permit**, sela c√°psula e SIRP.
    3.  Assistive-LLM pode enriquecer **derivados** (HTML/PDF/explica√ß√£o), nunca os bytes can√¥nicos.

* * *

Regras de bolso (para n√£o escorregar)
=====================================

*   **Core = determinismo + BASE-only.** Chamou rede/LLM? ent√£o **n√£o** √© Core.
*   Promova a **Core** s√≥ o que:
    1.  √© usado por ‚â•3 produtos,
    2.  tem contrato est√°vel,
    3.  adiciona invariantes de seguran√ßa/canonicidade.
*   **Assistive-LLM nunca d√° ALLOW/DENY.** No m√°ximo produz **ASK/PoI** ou _draft_ de policy que passa por **KATs + consent + permit**.
*   **Domain** mant√©m os _mappers_ e _policy packs_ do setor; Core n√£o sabe do setor.

* * *

Layout sugerido
===============

```
/base
  ai-nrf1/           # bytes, encode/decode, cid
  ubl-capsule/       # id, seal, receipts, verify
/core
  intake-{doc,event,txn}/
  permit/
  sirp-{capsule,verify}/
  canon-{ai-json-nrf1,ubl-json-view}/
  enrich-{badge,status,ghost,pdf}/
/assistive-llm
  llm_mapper/
  llm_policy_assistant/
  llm_enricher/
  llm_router/
  llm_guard/
/domain
  api-gateway/
  model-passport/
  compliance-{soc2,hipaa,finra}/
/products
  api-receipt-gateway/   # bin√°rio
  ai-model-passport/     # bin√°rio
  notarize-and-prove/    # bin√°rio
```

**Features no produto (exemplo):**

```toml
[features]
core = ["permit", "sirp-capsule", "canon-ai-json-nrf1", "enrich-status"]
domain_api = ["domain/api-gateway", "core"]
assist_llm = ["llm_mapper", "llm_enricher"]  # opcional

