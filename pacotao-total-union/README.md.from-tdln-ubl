# Pacot√£o: `ubl` + TDLN + LLM (Engine/Smart) + cap-runtime + Bench üéÅ

Este pacote adiciona **4 comandos** dentro do `ubl`:
1) `ubl tdln policy` ‚Äî tdln puro com pol√≠ticas ‚Üí **recibo + URL**
2) `ubl tdln runtime` ‚Äî tdln com **Certified Runtime** ‚Üí **recibo + URL**
3) `ubl llm engine` ‚Äî LLM **premium** TURBINADO por tdln (pr√©-processamento)
4) `ubl llm smart`  ‚Äî LLM **local/8B** TURBINADO por tdln (pr√©-processamento)

Al√©m disso, entrega:
- `modules/cap-runtime/` (skeleton) ‚Äî descreve execu√ß√£o certificada via efeitos.
- Manifests prontos (`manifests/tdln/*`, `manifests/llm/*`).
- Bundles (`configs/bundles/*`).
- Benchmarks (`benches/llm/*`) e o utilit√°rio `bench-report`.

---

## Como aplicar no seu repo

1. **Copie** as pastas/arquivos deste pacote para as mesmas localiza√ß√µes no repo.
2. **Aplique os patches**:
   - `patches/tools_ubl_cli_main_rs.patch` ‚Üí `tools/ubl-cli/src/main.rs`
   - `patches/tools_ubl_cli_Cargo_toml.patch` ‚Üí `tools/ubl-cli/Cargo.toml`
   - `patches/workspace_Cargo_toml.patch` ‚Üí `Cargo.toml` (workspace)
3. **Build**:
```bash
cargo build -p ubl-cli -p bench-report -p cap-runtime
```
> Obs: `cap-runtime` pode compilar isolado; os m√≥dulos reais e o executor de effects j√° existem no workspace.

---

## Uso r√°pido

### 1) tdln puro com pol√≠ticas
```bash
ubl tdln policy --help
ubl tdln policy run --manifest manifests/tdln/policy.yaml --out -
```

### 2) tdln com Certified Runtime
```bash
ubl tdln runtime run --manifest manifests/tdln/runtime.yaml --out -
```

### 3) llm engine (premium)
```bash
ubl llm engine run --out -
ubl llm engine bench --suite benches/llm/suites/base.yaml --reps 5 --out engine.jsonl
```

### 4) llm smart (local)
```bash
ubl llm smart run --out -
ubl llm smart bench --suite benches/llm/suites/base.yaml --reps 5 --out smart.jsonl
```

### Relat√≥rio de benchmark
```bash
bench-report --inputs engine.jsonl smart.jsonl > report.md
```

---

## Como isso atende sua especifica√ß√£o

- **Produtos** usando **tdln puro** (1) e **tdln + runtime** (2): prontos via `ubl tdln ...` e manifests dedicados.
- **LLM Engine** (3) e **LLM Smart** (4): wrappers que **englobam** o tdln no pr√≥prio pipeline (pr√©-processo determin√≠stico), focados em **performance/custo**.
- **Recibos + URL**: os manifests j√° incluem `cap-enrich` e `cap-transport` (publica√ß√£o e rendering). A URL rica resolve o `receipt_cid`.
- **Arquitetura**: BASE (canon/recibo), M√ìDULOS (`cap-*`), **CLI** (`ubl`/tdln/llm), **PRODUTOS** (manifests ou comandos cli como bundles).

---

## Pr√≥ximos passos (sugeridos)

- Conectar `ubl tdln run` ao **module-runner in-process** (substituir stub, se ainda houver).
- Adicionar providers LLM no **executor** (OpenAI/Anthropic/Ollama) conforme suas features/keys.
- Preencher `policy.refs` com CIDs reais e templates de `cap-enrich`.
- Habilitar **attestation** completa no executor do `cap-runtime` e expor em `/resolve/{cid}`.

Qualquer ajuste, √© s√≥ falar. Boa integra√ß√£o! üîßüöÄ
