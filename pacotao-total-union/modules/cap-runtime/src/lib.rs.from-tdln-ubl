//! Módulo cap-runtime (skeleton): planeja execução certificada e emite Effects.
//! Não executa IO diretamente; emite WriteStorage + Webhook com o plano.
//! O executor externo coleta attestation e publica recibos.

use anyhow::{anyhow, Context, Result};
use modules_core::{CapInput, CapOutput, Capability, Effect, Artifact};
use serde::Deserialize;
use serde_json::{json, Value};

#[derive(Debug, Deserialize)]
struct Limits { cpu_ms: u32, memory_mb: u32, wall_ms: u32 }

#[derive(Debug, Deserialize)]
struct Config {
    executor: String,
    limits: Limits,
    #[serde(default)] code_input: Option<String>,
    #[serde(default)] data_input: Option<String>,
    webhook_binding: String,
}

#[derive(Default)]
pub struct RuntimeModule;

impl Capability for RuntimeModule {
    fn kind(&self) -> &'static str { "cap-runtime" }
    fn api_version(&self) -> &'static str { "1.0" }

    fn validate_config(&self, cfg: &serde_json::Value) -> Result<()> {
        let c: Config = serde_json::from_value(cfg.clone())
            .context("cap-runtime: config inválida")?;
        if c.code_input.is_none() && c.data_input.is_none() {
            return Err(anyhow!("cap-runtime: informe code_input ou data_input"));
        }
        Ok(())
    }

    fn execute(&self, input: CapInput) -> Result<CapOutput> {
        let cfg: Config = serde_json::from_value(input.config.clone())
            .context("cap-runtime: config inválida")?;

        let env = input.env.unwrap_or_else(|| nrf1::Value::Null);
        let env_json: Value = modules_core::to_json(&env)?;

        let code_cid = cfg.code_input.as_ref().and_then(|k| env_json.get(k))
            .and_then(|v| v.get("cid")).and_then(|v| v.as_str()).map(|s| s.to_string());
        let data_cid = cfg.data_input.as_ref().and_then(|k| env_json.get(k))
            .and_then(|v| v.get("cid")).and_then(|v| v.as_str()).map(|s| s.to_string());

        let plan = json!({
            "executor": cfg.executor,
            "limits": { "cpu_ms": cfg.limits.cpu_ms, "memory_mb": cfg.limits.memory_mb, "wall_ms": cfg.limits.wall_ms },
            "inputs": { "code_cid": code_cid, "data_cid": data_cid },
            "attestation": { "require_quote": true },
        });
        let plan_bytes = serde_json::to_vec(&plan)?;

        let plan_artifact = Artifact {
            cid: None,
            mime: "application/json".into(),
            bytes: plan_bytes.clone(),
            name: Some("runtime-plan.json".into()),
        };

        let write_effect = Effect::WriteStorage {
            path: format!("runtime-plans/{}/{}.json", input.tenant, input.trace_id),
            bytes: plan_bytes,
            mime: "application/json".into(),
        };
        let webhook_effect = Effect::Webhook {
            url: format!("${{{}}}", cfg.webhook_binding),
            body: serde_json::to_vec(&json!({
                "tenant": input.tenant,
                "trace_id": input.trace_id,
                "step_id": input.step_id,
                "plan": plan,
            }))?,
            content_type: "application/json".into(),
            hmac_key_env: None,
        };

        Ok(CapOutput{
            new_env: None,
            verdict: None,
            artifacts: vec![plan_artifact],
            effects: vec![write_effect, webhook_effect],
            metrics: vec![("runtime.request".to_string(), 1)],
        })
    }
}
