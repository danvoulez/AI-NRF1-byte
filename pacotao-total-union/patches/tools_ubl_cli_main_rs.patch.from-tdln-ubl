*** Begin Patch
*** Update File: tools/ubl-cli/src/main.rs
@@
-    Llm {
-        #[command(subcommand)]
-        cmd: LlmCmd,
-    },
+    Llm {
+        #[command(subcommand)]
+        cmd: LlmCmd,
+    },
+    /// Orquestração declarativa tdln (policy|runtime)
+    Tdln {
+        #[command(subcommand)]
+        cmd: TdlnCmd,
+    },
@@
-#[derive(Subcommand)]
-enum LlmCmd {
-    /// Run a completion
-    Complete
+#[derive(Subcommand)]
+enum LlmCmd {
+    /// Run a completion
+    Complete,
+    /// Premium providers com tdln
+    Engine { #[command(flatten)] args: modules::RunArgs },
+    /// Local providers com tdln
+    Smart  { #[command(flatten)] args: modules::RunArgs },
 }
+
+#[derive(Subcommand)]
+enum TdlnCmd {
+    /// Pipeline puro com políticas
+    Policy { #[command(flatten)] args: modules::RunArgs },
+    /// Pipeline com Certified Runtime
+    Runtime { #[command(flatten)] args: modules::RunArgs },
+}
@@
 use clap::{Parser, Subcommand};
+mod modules;
@@
         Cmd::Llm { cmd } => {
-            // existing llm logic ...
+            match cmd {
+                LlmCmd::Engine { args } => modules::run_llm("engine", args)?,
+                LlmCmd::Smart  { args } => modules::run_llm("smart",  args)?,
+                _ => { /* mantém comandos LLM existentes */ }
+            }
         }
+        Cmd::Tdln { cmd } => {
+            match cmd {
+                TdlnCmd::Policy { args }  => modules::run_tdln("policy", args)?,
+                TdlnCmd::Runtime { args } => modules::run_tdln("runtime", args)?,
+            }
+        }
*** End Patch
